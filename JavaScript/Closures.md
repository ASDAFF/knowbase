# Введение

Одним из самых мощных инструментов язка JavaScript считают возможность создавать замыкания. Это такой приём, когда новые
области видимости (например, функций) всегда имеют доступ к внешней области, в которых они были объявлены. Собственно, 
единственный механизм создания областей видимости в JavaScript — это и есть функции: таким образом, объявляя функцию, вы
автоматически реализуете замыкания. Или, другими словами: любая объявленная функция по умолчанию ведёт себя как 
замыкание.

## Эмуляция приватных переменных

```javascript
function Counter(start) {
    var count = start;
    return {
        increment: function() {
            count++;
        },

        get: function() {
            return count;
        }
    }
}

var foo = Counter(4);
foo.increment();
foo.get(); // 5
```

В данном примере `Counter` возвращает два замыкания: функции `increment` и `get`. Обе эти функции сохраняют внутри себя 
ссылку на область видимости `Counter` и, соответственно, имеют свободный доступ к переменной `count` из этой самой 
области.

## Как работают приватные переменные

Поскольку в JavaScript нельзя присваивать или ссылаться на области видимости, заполучить `count` 
извне — не представляется возможным. Единственный способ взаимодействовать с этой переменной — изменять её внутри двух 
описанных замыканий.

```javascript
var foo = new Counter(4);
foo.hack = function() {
    count = 1337;
};
```

В приведенном примере мы не изменяем переменную `count` из области видимости `Counter`, т.к. `foo.hack` не объявлен 
в той области. Вместо этого будет создана или перезаписана глобальная переменная `count`. Замена 
кода внутри `foo.hack` на `this.count` = 1337, не поможет, конечно же, тоже, поскольку `count` никогда не был свойством 
объекта `Counter`, а был лишь внутренней переменной.

## Замыкания внутри циклов

Существует одна, довольно часто встречающаяся, ловушка — когда замыкания используют внутри циклов, передавая переменную 
индекса внутрь.

```javascript
for(var i = 0; i < 10; i++) {
    setTimeout(function() {
        console.log(i);
    }, 1000);
}
```

Данный код не будет выводить числа с `0` до `9` — вместо этого число `10` будет выведено десять раз.

Анонимная функция сохраняет лишь ссылку на `i`, и когда будет вызвана функция `console.log`, цикл `for` уже закончит 
свою работу — и поэтому в переменной `i` будет покоиться значение `10`.

Для получения желаемого результата необходимо создать копию переменной `i`.

## Обход проблемы со ссылкой

Для того, чтобы скопировать значение индекса из цикла, лучше всего использовать другую анонимную функцию как обёртку.

```javascript
for(var i = 0; i < 10; i++) {
    (function(e) {
        setTimeout(function() {
            console.log(e);
        }, 1000);
    })(i);
}
```

Анонимная функция-обертка вызывается сразу же, и в качестве первого аргумента получает индекс `i`, значение которого 
будет скопировано в параметр `e`.

Анонимная функция, которая передается в `setTimeout`, теперь содержит ссылку на переменную `e`, значение которой 
не изменяется циклом.

Этот приём можно реализовать и другим способом — возвратив нужную функции из анонимной функции-обертки — поведение 
такого кода будет идентично поведению кода из предыдущего примера.


```javascript
for(var i = 0; i < 10; i++) {
    setTimeout((function(e) {
        return function() {
            console.log(e);
        }
    })(i), 1000)
}
```

Переменную `e` можно тоже назвать `i`, если вы хотите: это не поменяет поведения кода — внутренняя 
переменная `i` всё так же будет копией внешней переменной.

В качестве упражнения на замыкания и анонимные функции, попробуйте заменить оборачивающие вызовы анонимных 
функций в примерах на варианты с `.call` и `.apply`.

[Источник: перевод "Javascript Garden"](http://shamansir.github.io/JavaScript-Garden/#function.closures)

# Приемы использования замыканий

## Управление доступом

Замыкания позволяют инкапсулировать данные и организовывать к ним доступ из внешнего контекста

Создаем функцию `Human`, конструктор которой принимает `1` аргумент - возраст.

```javascript
var Human = function (age) {
	return {
		getAge: function () {
			return age;
		}
	}
}
```

Создадим объект `dmitriy` с возрастом `22`

```javascript
var dmitriy = new Human(22);
console.log('Dmitriy has ' + dmitriy.getAge() + ' level!'); // Dmitriy has 22 level!
console.log(dmitriy.age); // undefined
```

Если мы попробуем обратиться к свойству `age` у этого объекта то браузер сообщит нам, что оно не объявлено. Метод
`getAge` использует не свойство объекта, а переменную замыкания которая была передана как аргумент в конструктор `Human`

```javascript
dmitriy.age = 25

console.log('Dmitriy has ' + dmitriy.getAge() + ' level!'); // Dmitriy has 22 level!
console.log(dmitriy.age); // 25
```

После того, как мы установим свойство `age` у объекта `dmitriy`, метод `getAge` будет возвращать то же значение, что и 
до этого, потому что свойство объекта `dmitriy` никак не влияет на переменную в замыкании функции `Human`
 
Чтобы иметь возможность задавать возраст мы немного изменим функцию `Human`


```javascript
var Human = function (age) {
	return {
		getAge: function () {
			return age;
		},
		setAge: function (value) {
			age = value;
		
			return this;
		}
	}
}

var dmitriy = new Human();

console.log(dmitriy.getAge()); // undefined

dmitriy.setAge(22);

console.log(dmitriy.getAge()); // 22
```
## Инкапсуляция

В нашем рабочем процессе на битриксе замыкания полезно использовать как изолирование логических кусков кода от 
глобального контекста и, если нужно - предоставление внешнего интерфейса:

```javascript
var carousel = (function () {
    var $container = $('.carousel');
    
    return {
        destroy: function () {
            $container.carousel('destroy');
        },
        init: function () {
            $container.carousel();
        }
    }
}());
```

Здесь мы создали объект `carousel` с двумя функциями `init`, `destroy`. Переменная `$container` недоступна из 
глобального контекста, она доступна только функциям `init` и `destroy`. Это позволяет создавать нам много различных логических 
кусочков с одинаковыми лакончиными именами переменных, которые не будут пересекаться в глобальной области видимости. 
 
Так же появилась новая для вас конструкция:

```javascript
(function () {
}());
```

Это немедленно вызываемая функция. Эта функция срабатывает сразу же после объявления и возвращает результат выполнения.
Очень полезный функционал, который позволяет создавать локальную область видимости и с помощью замыканий предоставлять
внешний интерфейс по взаимодействию с этой областью видимости.

# Производительность замыканий

Ну и наконец - стоит упомянуть, что доступ к переменным из сильно 'вложенных' замыканий замедляется подобно 
доступу к свойствам сильноудаленного родительского прототипа. Решением этой проблемы является сохранение 
локальной ссылки на переменную замыкания.